dev.off()
n_model <- unique(pop$model)
n_model
## This program is used to make taylor plots
## questions about this code contract Yi Xu, yi.xu2@dfo-mpo.gc.ca
rm(list=ls())
#setwd("C:/DFO-MPO/Work/Sockeye_paper/code") #set up your own directory that include all the updated env files
library(tidyverse)
#library(plotrix)
source(here::here("code","mytaylor.R"))
fc <- read_csv(here::here("data","historical_fc.csv"),show_col_types = FALSE)
retro <- read_csv(here::here("data","retro_all_newmodels.csv"))
retro <- retro %>%
mutate(model = replace(model, model=="RickerPi","RickerPi.SST"),
model = replace(model, model=="RickerEi","RickerEi.SST"),
model = replace(model, model=="RickerGOA.SST.Ann","RickerGOA.SST"),
model = replace(model, model=="LarkinBasicCycAge","LarkinCyc"),
model = replace(model, model=="PowerBasicCycAge","PowerCyc")) %>%
filter(!model %in% c("RickerGOA.SST.Sum",
"RickerGOA.SST.Win",
"RickerNPGO.Ann","RickerNPGO.Sum","RickerNPGO.Win"))
oldricker<-c("RickerBasic","RickerCyc","RickerEi.SST","RickerFRDMean","RickerFRDpeak",
"RickerPDO","RickerPi.SST")
oldpower<-c("PowerBasic","PowerCyc","PowerJuv","PowerJuvPi","PowerJuvEi",
"PowerFRDpeak","PowerPi")
pname<-unique(fc$Stock)
myseries <-c(3,4,0,1,2,5,6,7,8,9)
n_model <- c("RickerBasic","RickerCyc",
"RickerEi.SST","RickerPi.SST","RickerFRDMean","RickerFRDpeak","RickerPDO",
"RickerGOA.SST.Ann","RickerSockeye","RickerChum","RickerPink","RickerSalmon_Total",
"LarkinBasic", "LarkinCyc","PowerBasic","PowerCyc","PowerPi",
"PowerSockeye","PowerChum" ,"PowerPink","PowerSalmon_Total",
"LLY","R1C","R2C","RAC","TSA","RS1","RS2","RSC","MRS","RS4yr","RS8yr")
#filename=paste0("plot_taylor_Summer_Late.png")
filename=paste0("plot_taylor_Early_Summer.png")
png(here::here("plot",filename),h=1500,w=1500)
par(mfrow=c(3,3),omi = c(1, 1, 1, 4),xpd = NA)
for (j in c(4,14,16,17,18,15,8,1,11)){
#for (j in c(7,2,6,3,5,9,12,13,10)){
if(j == 1) mytitlecolor <- "black"
if(j %in% c(11,9,12,13,10)) mytitlecolor <- "purple"
if(j %in% c(4,14,16,17,18,15,8)) mytitlecolor <- "darkgreen"
if(j %in% c(7,2,6,3,5)) mytitlecolor <- "blue"
print(paste("Pop=",j))
pop <- retro %>% filter(popID==j&age==99)
#n_model <- unique(pop$model)
tot_n_model <- pop %>% distinct(model)
idx_larkin<-grep("Larkin",n_model)
idx_power<-grep("Power",n_model)
idx_power_old<-idx_power[n_model[idx_power]%in%oldpower]
idx_power_new<-idx_power[!n_model[idx_power]%in%oldpower]
idx_ricker<-grep("Ricker",n_model)
idx_ricker_old<-idx_ricker[n_model[idx_ricker]%in%oldricker]
idx_ricker_new<-idx_ricker[!n_model[idx_ricker]%in%oldricker]
idx_sib<-grep("sibling5",n_model)
idx_jack<-grep("Jacksib",n_model)
idx_naive<-which(n_model%in%n_model[-c(idx_power,idx_ricker,idx_larkin,idx_sib)])
mypch<-mycolor<-rep(NA,length(n_model))
mycolor[idx_larkin]<-"gold"
mypch[idx_larkin]<-(1:length(idx_larkin))+2
mycolor[idx_power_old]<-"#61D04F" #green
mypch[idx_power_old]<-myseries[1:length(idx_power_old)]
mycolor[idx_power_new]<-"blue"
mypch[idx_power_new]<-myseries[3:(length(idx_power_new)+2)]
mycolor[idx_ricker_old]<-"pink"
mypch[idx_ricker_old]<-myseries[1:length(idx_ricker_old)]
mycolor[idx_ricker_new]<-"red"
mypch[idx_ricker_new]<-myseries[3:(length(idx_ricker_new)+2)]
mycolor[idx_naive]<-"mediumpurple1"
mypch[idx_naive]<-0:(length(idx_naive)-1)
mycolor[idx_sib]<-"grey"
mypch[idx_sib]<-15
mycolor[idx_jack]<-"grey"
mypch[idx_jack]<-16
for (k in 1:length(tot_n_model$model)){
want <- pop %>% filter(model==tot_n_model$model[k]&age==99) %>%
mutate(diff=p50-obs,p50,obs=obs/1e6) %>% filter(!is.na(diff)) %>%
select(retyr,p50,obs) %>%
left_join(fc %>% filter(popID==j) %>% select(retyr,Stock,fc),by="retyr") %>% mutate(fc=fc/1e6)
if(k==1) taylor.diagram(want$obs,want$obs,normalize=T,pch=16,pcex = 4,main=pname[j],col="black",cex=2,col.main = mytitlecolor,cex.main=3,ref.sd = T,xlab = "")
#if(k==1) taylor.diagram(want$obs,want$fc,normalize=T,pch=15,pcex = 4,add=T,col="black")
idx<-which(tot_n_model$model[k]==n_model)
taylor.diagram(want$obs,want$p50,add = T,pch=mypch[idx],col=mycolor[idx],normalize=T,pcex = 3,lwd = 2)
}
taylor.diagram(want$obs,want$fc,normalize=T,pch=15,pcex = 3,add=T,col="black")
mtext("Taylor Diagram",side=3,line=0.5,cex=3.5,outer = T)
mtext("Standard deviation",side=1,line=2,cex=2,outer = T)
mtext("Standard deviation",side=2,line=2,cex=2,outer = T)
if(j == 15|j == 9) legend("right",c("Observation","Forecast",n_model),
pch=c(16,15,mypch),
col=c("black","black",mycolor),
cex = 3,inset = c(-0.9,1),xpd = NA,
bg=NA,bty = "n",ncol=1,pt.lwd = 2) #else
#taylor.diagram(want$obs,want$fc,normalize=T,pch=15,pcex = 4,add=T,col="black")
}
dev.off()
rm(list=ls())
setwd("C:/DFO-MPO/Work/Sockeye/Retrospective_2021/Fraser-Sockeye-Forecast-master/OUTPUT/") #set up your own directory that include all the updated env files
library(tidyverse)
retro <-read_csv("retro_all_newmodels.csv",show_col_types = FALSE)
retro <-read_csv(here::here("data","retro_all_newmodels.csv"),show_col_types = FALSE)
#retro <-read_csv("retro_all.csv",show_col_types = FALSE)
my_error <- function(obs,est,dev.type="all"){ #adpated from Gottfried code retro.pm.fun
devs <- est-obs
dev.logs <- log(est) - log(obs)
n.devs <- sum(!is.na(devs))
mre <- sum(devs,na.rm=TRUE)/n.devs ; mre.log <- sum(dev.logs,na.rm=TRUE)/n.devs
mae <- sum(abs(devs),na.rm=TRUE)/n.devs ; mae.log <- sum(abs(dev.logs),na.rm=TRUE)/n.devs
mpe <- sum(devs/obs,na.rm=TRUE)/n.devs ; mpe.log <- sum(dev.logs/log(obs),na.rm=TRUE)/n.devs
rmse <- sqrt(sum(devs^2,na.rm=TRUE)/n.devs); rmse.log <- sqrt(sum(dev.logs^2,na.rm=TRUE)/n.devs)
retro.pm.out <- matrix(NA,nrow=2,ncol=4,dimnames=list(c("RawDev","DevLog"),c("MRE","MAE","MPE","RMSE")))
retro.pm.out["RawDev",] <-  c(mre,mae,mpe,rmse)
retro.pm.out["DevLog",] <-  c(mre.log,mae.log,mpe.log,rmse.log)
if(dev.type != "all"){ retro.pm.out <- retro.pm.out[dev.type,] }
return(retro.pm.out[1,])
}
pname<-c( "Early Stuart", "Late Stuart","Stellako",
"Bowron","Raft","Quesnel", "Chilko","Seymour",
"Late Shuswap", "Birkenhead","Cultus","Portage",
"Weaver" ,"Upper Barriere(Fennell)","Scotch",
"Gates","Nadina","Pitt","Harrison")
age_spec <-c(4,5,99)
## This program is used to create Ranking tables##
## and output to retro_all.csv
## questions about this code contract Yi Xu, yi.xu2@dfo-mpo.gc.ca
rm(list=ls())
library(tidyverse)
retro <-read_csv(here::here("data","retro_all_newmodels.csv"),show_col_types = FALSE)
#retro <-read_csv("retro_all.csv",show_col_types = FALSE)
my_error <- function(obs,est,dev.type="all"){ #adpated from Gottfried code retro.pm.fun
devs <- est-obs
dev.logs <- log(est) - log(obs)
n.devs <- sum(!is.na(devs))
mre <- sum(devs,na.rm=TRUE)/n.devs ; mre.log <- sum(dev.logs,na.rm=TRUE)/n.devs
mae <- sum(abs(devs),na.rm=TRUE)/n.devs ; mae.log <- sum(abs(dev.logs),na.rm=TRUE)/n.devs
mpe <- sum(devs/obs,na.rm=TRUE)/n.devs ; mpe.log <- sum(dev.logs/log(obs),na.rm=TRUE)/n.devs
rmse <- sqrt(sum(devs^2,na.rm=TRUE)/n.devs); rmse.log <- sqrt(sum(dev.logs^2,na.rm=TRUE)/n.devs)
retro.pm.out <- matrix(NA,nrow=2,ncol=4,dimnames=list(c("RawDev","DevLog"),c("MRE","MAE","MPE","RMSE")))
retro.pm.out["RawDev",] <-  c(mre,mae,mpe,rmse)
retro.pm.out["DevLog",] <-  c(mre.log,mae.log,mpe.log,rmse.log)
if(dev.type != "all"){ retro.pm.out <- retro.pm.out[dev.type,] }
return(retro.pm.out[1,])
}
pname<-c( "Early Stuart", "Late Stuart","Stellako",
"Bowron","Raft","Quesnel", "Chilko","Seymour",
"Late Shuswap", "Birkenhead","Cultus","Portage",
"Weaver" ,"Upper Barriere(Fennell)","Scotch",
"Gates","Nadina","Pitt","Harrison")
age_spec <-c(4,5,99)
tb <- tibble()
for (ipop in 1:18){
for (j in 3:3){ #age
pop <- retro %>% filter(popID==ipop&retyr%in%2009:2020) %>% mutate(obs=obs/1e6)
if(ipop==19) {
pop$age[pop$model=="sibling5"]<-4
pop$model[pop$model=="sibling5"]<-"sibling4"}
uniq_models <-unique(pop$model)
for (k in 1:1){
if(k==1) yr_select<-2009:2020
if(k==2) yr_select<-seq(2018,2009,-4)
if(k==3) yr_select<-c(2009,2011:2013,2015:2017,2019:2020)
yrname<-case_when(k==1 ~ "Allyrs",
k==2 ~ "cycyrs",
k==3 ~ "otheryrs")
pop_select <- pop %>% filter(retyr%in%yr_select)
out<-NULL
for (i in 1:length(uniq_models)){
tmp <- pop_select %>%
filter(age==age_spec[j]&model==uniq_models[i])
if(nrow(tmp)>=1) out <- bind_rows(out,as_tibble_row(my_error(tmp$obs,tmp$p50)) %>% mutate(model=uniq_models[i]))
}
pop_rank <- out %>%
select(model,MRE,MAE,MPE,RMSE) %>%
# mutate(MRE=round(MRE*1e3)/1e3,
#        MAE=round(MAE*1e3)/1e3,
#        MPE=round(MPE*1e3)/1e3,
#        RMSE=round(RMSE*1e3)/1e3) %>%
mutate(MRE_rank=rank(abs(MRE)),
MAE_rank=rank(abs(MAE)),
MPE_rank=rank(abs(MPE)),
RMSE_rank=rank(RMSE),
average=(MRE_rank+MAE_rank+MPE_rank+RMSE_rank)/4,
Overall_rank=rank(average,ties.method="first")) %>%
mutate(pop = ipop, age = age_spec[j]) %>%
arrange(Overall_rank)
tb <- bind_rows(tb,pop_rank)
#fn<-paste0("retro_",pname[ipop],"_age_",age_spec[j],"newmodels_",yrname,".csv")
#fn<-paste0("ranking_tables/retro_",pname[ipop],"_age_",age_spec[j],".csv")
#write_csv(pop_rank,file = fn)
} #end k of select years
} # end j with age
} # end ipop population ID
write_csv(tb,file = here:here("data","organize_retro.csv"))
write_csv(tb,file = here::here("data","organize_retro.csv"))
write_csv(tb,file = "../data/organize_retro.csv"))
write_csv(tb,file = "../data/organize_retro.csv")
nrow(out)
length(out)
out %>% mutate( freq = n/sum(n))
out %>% summarize(n = n()) %>%mutate( freq = n/sum(n))
pop_rank <- out %>%
select(model,MRE,MAE,MPE,RMSE) %>%
# mutate(MRE=round(MRE*1e3)/1e3,
#        MAE=round(MAE*1e3)/1e3,
#        MPE=round(MPE*1e3)/1e3,
#        RMSE=round(RMSE*1e3)/1e3) %>%
mutate(MRE_rank=rank(abs(MRE)),
MAE_rank=rank(abs(MAE)),
MPE_rank=rank(abs(MPE)),
RMSE_rank=rank(RMSE),
average=(MRE_rank+MAE_rank+MPE_rank+RMSE_rank)/4,
Overall_rank=rank(average,ties.method="first")) %>%
mutate(pop = ipop, age = age_spec[j]) %>%
summarize(n = n()) %>%
mutate(rel_rank_RMSE = RMSE_rank/sum(n))
pop_rank
pop_rank <- out %>%
select(model,MRE,MAE,MPE,RMSE) %>%
# mutate(MRE=round(MRE*1e3)/1e3,
#        MAE=round(MAE*1e3)/1e3,
#        MPE=round(MPE*1e3)/1e3,
#        RMSE=round(RMSE*1e3)/1e3) %>%
mutate(MRE_rank=rank(abs(MRE)),
MAE_rank=rank(abs(MAE)),
MPE_rank=rank(abs(MPE)),
RMSE_rank=rank(RMSE),
average=(MRE_rank+MAE_rank+MPE_rank+RMSE_rank)/4,
Overall_rank=rank(average,ties.method="first")) %>%
mutate(pop = ipop, age = age_spec[j]) %>%
summarize(n = n())
pop_rank <- out %>%
select(model,MRE,MAE,MPE,RMSE) %>%
# mutate(MRE=round(MRE*1e3)/1e3,
#        MAE=round(MAE*1e3)/1e3,
#        MPE=round(MPE*1e3)/1e3,
#        RMSE=round(RMSE*1e3)/1e3) %>%
mutate(MRE_rank=rank(abs(MRE)),
MAE_rank=rank(abs(MAE)),
MPE_rank=rank(abs(MPE)),
RMSE_rank=rank(RMSE),
average=(MRE_rank+MAE_rank+MPE_rank+RMSE_rank)/4,
Overall_rank=rank(average,ties.method="first")) %>%
mutate(pop = ipop, age = age_spec[j]) %>%
mutate(rel_rank_RMSE = RMSE_rank/count(model))
pop_rank <- out %>%
select(model,MRE,MAE,MPE,RMSE) %>%
# mutate(MRE=round(MRE*1e3)/1e3,
#        MAE=round(MAE*1e3)/1e3,
#        MPE=round(MPE*1e3)/1e3,
#        RMSE=round(RMSE*1e3)/1e3) %>%
mutate(MRE_rank=rank(abs(MRE)),
MAE_rank=rank(abs(MAE)),
MPE_rank=rank(abs(MPE)),
RMSE_rank=rank(RMSE),
average=(MRE_rank+MAE_rank+MPE_rank+RMSE_rank)/4,
Overall_rank=rank(average,ties.method="first")) %>%
mutate(pop = ipop, age = age_spec[j]) %>%
mutate(rel_rank_RMSE = RMSE_rank/n())
pop_rank
View(pop_rank)
tb <- tibble()
for (ipop in 1:18){
for (j in 3:3){ #age
pop <- retro %>% filter(popID==ipop&retyr%in%2009:2020) %>% mutate(obs=obs/1e6)
if(ipop==19) {
pop$age[pop$model=="sibling5"]<-4
pop$model[pop$model=="sibling5"]<-"sibling4"}
uniq_models <-unique(pop$model)
for (k in 1:1){
if(k==1) yr_select<-2009:2020
if(k==2) yr_select<-seq(2018,2009,-4)
if(k==3) yr_select<-c(2009,2011:2013,2015:2017,2019:2020)
yrname<-case_when(k==1 ~ "Allyrs",
k==2 ~ "cycyrs",
k==3 ~ "otheryrs")
pop_select <- pop %>% filter(retyr%in%yr_select)
out<-NULL
for (i in 1:length(uniq_models)){
tmp <- pop_select %>%
filter(age==age_spec[j]&model==uniq_models[i])
if(nrow(tmp)>=1) out <- bind_rows(out,as_tibble_row(my_error(tmp$obs,tmp$p50)) %>% mutate(model=uniq_models[i]))
}
pop_rank <- out %>%
select(model,MRE,MAE,MPE,RMSE) %>%
# mutate(MRE=round(MRE*1e3)/1e3,
#        MAE=round(MAE*1e3)/1e3,
#        MPE=round(MPE*1e3)/1e3,
#        RMSE=round(RMSE*1e3)/1e3) %>%
mutate(MRE_rank=rank(abs(MRE)),
MAE_rank=rank(abs(MAE)),
MPE_rank=rank(abs(MPE)),
RMSE_rank=rank(RMSE),
average=(MRE_rank+MAE_rank+MPE_rank+RMSE_rank)/4,
Overall_rank=rank(average,ties.method="first")) %>%
mutate(pop = ipop, age = age_spec[j]) %>%
mutate(rel_rank_RMSE = RMSE_rank/n(),
rel_rank_all = Overall_rank/n()) %>%
arrange(Overall_rank)
tb <- bind_rows(tb,pop_rank)
#fn<-paste0("retro_",pname[ipop],"_age_",age_spec[j],"newmodels_",yrname,".csv")
#fn<-paste0("ranking_tables/retro_",pname[ipop],"_age_",age_spec[j],".csv")
#write_csv(pop_rank,file = fn)
} #end k of select years
} # end j with age
} # end ipop population ID
View(tb)
new <- tb %>%
pivot_wider(names_from = model, values_from = rel_rank_all)
View(new)
new <- tb %>%
filter(pop, model, rel_rank_all)
new <- tb %>%
select(pop, model, rel_rank_all)
View(new)
pivot_wider(names_from = model, values_from = c(pop,rel_rank_all))
new <- tb %>%
select(pop, model, rel_rank_all) %>%
pivot_wider(names_from = model, values_from = c(pop,rel_rank_all))
new <- tb %>%
select(pop, model, rel_rank_all) %>%
pivot_wider(names_from = pop, values_from = c(model,rel_rank_all))
new <- tb %>%
select(pop, model, rel_rank_all) %>%
pivot_wider(names_from = pop, values_from = model)
View(new)
new <- tb %>%
select(pop, model, rel_rank_all) %>%
pivot_wider(names_from = pop, values_from = rel_rank_all)
View(new)
library(ggplot2)
ggplot(tb,aes(x = pop, y = model, fill = rel_rank_all)) +
geom_tile()
ggplot(tb,aes(x = pop, y = model, fill = rel_rank_all)) +
geom_tile()
View(tb)
ggplot(tb,aes(x = pop, y = model, fill = rel_rank_all)) +
geom_tile(colour = "white", size = 0.2)
## This program is used to create Ranking tables##
## and output to retro_all.csv
## questions about this code contract Yi Xu, yi.xu2@dfo-mpo.gc.ca
rm(list=ls())
library(tidyverse)
retro <-read_csv(here::here("data","retro_all_newmodels.csv"),show_col_types = FALSE)
#retro <-read_csv("retro_all.csv",show_col_types = FALSE)
my_error <- function(obs,est,dev.type="all"){ #adpated from Gottfried code retro.pm.fun
devs <- est-obs
dev.logs <- log(est) - log(obs)
n.devs <- sum(!is.na(devs))
mre <- sum(devs,na.rm=TRUE)/n.devs ; mre.log <- sum(dev.logs,na.rm=TRUE)/n.devs
mae <- sum(abs(devs),na.rm=TRUE)/n.devs ; mae.log <- sum(abs(dev.logs),na.rm=TRUE)/n.devs
mpe <- sum(devs/obs,na.rm=TRUE)/n.devs ; mpe.log <- sum(dev.logs/log(obs),na.rm=TRUE)/n.devs
rmse <- sqrt(sum(devs^2,na.rm=TRUE)/n.devs); rmse.log <- sqrt(sum(dev.logs^2,na.rm=TRUE)/n.devs)
retro.pm.out <- matrix(NA,nrow=2,ncol=4,dimnames=list(c("RawDev","DevLog"),c("MRE","MAE","MPE","RMSE")))
retro.pm.out["RawDev",] <-  c(mre,mae,mpe,rmse)
retro.pm.out["DevLog",] <-  c(mre.log,mae.log,mpe.log,rmse.log)
if(dev.type != "all"){ retro.pm.out <- retro.pm.out[dev.type,] }
return(retro.pm.out[1,])
}
pname<-c( "Early Stuart", "Late Stuart","Stellako",
"Bowron","Raft","Quesnel", "Chilko","Seymour",
"Late Shuswap", "Birkenhead","Cultus","Portage",
"Weaver" ,"Upper Barriere(Fennell)","Scotch",
"Gates","Nadina","Pitt","Harrison")
age_spec <-c(4,5,99)
tb <- tibble()
for (ipop in 1:18){
for (j in 3:3){ #age
pop <- retro %>% filter(popID==ipop&retyr%in%2009:2020) %>% mutate(obs=obs/1e6)
if(ipop==19) {
pop$age[pop$model=="sibling5"]<-4
pop$model[pop$model=="sibling5"]<-"sibling4"}
uniq_models <-unique(pop$model)
for (k in 1:1){
if(k==1) yr_select<-2009:2020
if(k==2) yr_select<-seq(2018,2009,-4)
if(k==3) yr_select<-c(2009,2011:2013,2015:2017,2019:2020)
yrname<-case_when(k==1 ~ "Allyrs",
k==2 ~ "cycyrs",
k==3 ~ "otheryrs")
pop_select <- pop %>% filter(retyr%in%yr_select)
out<-NULL
for (i in 1:length(uniq_models)){
tmp <- pop_select %>%
filter(age==age_spec[j]&model==uniq_models[i])
if(nrow(tmp)>=1) out <- bind_rows(out,as_tibble_row(my_error(tmp$obs,tmp$p50)) %>% mutate(model=uniq_models[i]))
}
pop_rank <- out %>%
select(model,MRE,MAE,MPE,RMSE) %>%
# mutate(MRE=round(MRE*1e3)/1e3,
#        MAE=round(MAE*1e3)/1e3,
#        MPE=round(MPE*1e3)/1e3,
#        RMSE=round(RMSE*1e3)/1e3) %>%
mutate(MRE_rank=rank(abs(MRE)),
MAE_rank=rank(abs(MAE)),
MPE_rank=rank(abs(MPE)),
RMSE_rank=rank(RMSE),
average=(MRE_rank+MAE_rank+MPE_rank+RMSE_rank)/4,
Overall_rank=rank(average,ties.method="first")) %>%
mutate(pop = ipop, age = age_spec[j]) %>%
mutate(rel_rank_RMSE = RMSE_rank/n(),
rel_rank_all = Overall_rank/n()) %>%
arrange(Overall_rank)
tb <- bind_rows(tb,pop_rank)
#fn<-paste0("retro_",pname[ipop],"_age_",age_spec[j],"newmodels_",yrname,".csv")
#fn<-paste0("ranking_tables/retro_",pname[ipop],"_age_",age_spec[j],".csv")
#write_csv(pop_rank,file = fn)
} #end k of select years
} # end j with age
} # end ipop population ID
write_csv(tb,file = "../data/organize_retro.csv")
new <- tb %>%
select(pop, model, rel_rank_all) %>%
pivot_wider(names_from = pop, values_from = rel_rank_all)
library(ggplot2)
ggplot(tb,aes(x = pop, y = model, fill = rel_rank_all)) +
geom_tile(colour = "white", size = 0.2)
## This program is used to create Ranking tables##
## and output to retro_all.csv
## questions about this code contract Yi Xu, yi.xu2@dfo-mpo.gc.ca
rm(list=ls())
library(tidyverse)
retro <-read_csv(here::here("data","retro_all_newmodels.csv"),show_col_types = FALSE)
#retro <-read_csv("retro_all.csv",show_col_types = FALSE)
my_error <- function(obs,est,dev.type="all"){ #adpated from Gottfried code retro.pm.fun
devs <- est-obs
dev.logs <- log(est) - log(obs)
n.devs <- sum(!is.na(devs))
mre <- sum(devs,na.rm=TRUE)/n.devs ; mre.log <- sum(dev.logs,na.rm=TRUE)/n.devs
mae <- sum(abs(devs),na.rm=TRUE)/n.devs ; mae.log <- sum(abs(dev.logs),na.rm=TRUE)/n.devs
mpe <- sum(devs/obs,na.rm=TRUE)/n.devs ; mpe.log <- sum(dev.logs/log(obs),na.rm=TRUE)/n.devs
rmse <- sqrt(sum(devs^2,na.rm=TRUE)/n.devs); rmse.log <- sqrt(sum(dev.logs^2,na.rm=TRUE)/n.devs)
retro.pm.out <- matrix(NA,nrow=2,ncol=4,dimnames=list(c("RawDev","DevLog"),c("MRE","MAE","MPE","RMSE")))
retro.pm.out["RawDev",] <-  c(mre,mae,mpe,rmse)
retro.pm.out["DevLog",] <-  c(mre.log,mae.log,mpe.log,rmse.log)
if(dev.type != "all"){ retro.pm.out <- retro.pm.out[dev.type,] }
return(retro.pm.out[1,])
}
pname<-c( "Early Stuart", "Late Stuart","Stellako",
"Bowron","Raft","Quesnel", "Chilko","Seymour",
"Late Shuswap", "Birkenhead","Cultus","Portage",
"Weaver" ,"Upper Barriere(Fennell)","Scotch",
"Gates","Nadina","Pitt","Harrison")
age_spec <-c(4,5,99)
tb <- tibble()
for (ipop in 1:18){
for (j in 3:3){ #age
pop <- retro %>% filter(popID==ipop&retyr%in%2009:2020) %>% mutate(obs=obs/1e6)
if(ipop==19) {
pop$age[pop$model=="sibling5"]<-4
pop$model[pop$model=="sibling5"]<-"sibling4"}
uniq_models <-unique(pop$model)
for (k in 1:1){
if(k==1) yr_select<-2009:2020
if(k==2) yr_select<-seq(2018,2009,-4)
if(k==3) yr_select<-c(2009,2011:2013,2015:2017,2019:2020)
yrname<-case_when(k==1 ~ "Allyrs",
k==2 ~ "cycyrs",
k==3 ~ "otheryrs")
pop_select <- pop %>% filter(retyr%in%yr_select)
out<-NULL
for (i in 1:length(uniq_models)){
tmp <- pop_select %>%
filter(age==age_spec[j]&model==uniq_models[i])
if(nrow(tmp)>=1) out <- bind_rows(out,as_tibble_row(my_error(tmp$obs,tmp$p50)) %>% mutate(model=uniq_models[i]))
}
pop_rank <- out %>%
select(model,MRE,MAE,MPE,RMSE) %>%
# mutate(MRE=round(MRE*1e3)/1e3,
#        MAE=round(MAE*1e3)/1e3,
#        MPE=round(MPE*1e3)/1e3,
#        RMSE=round(RMSE*1e3)/1e3) %>%
mutate(MRE_rank=rank(abs(MRE)),
MAE_rank=rank(abs(MAE)),
MPE_rank=rank(abs(MPE)),
RMSE_rank=rank(RMSE),
average=(MRE_rank+MAE_rank+MPE_rank+RMSE_rank)/4,
Overall_rank=rank(average,ties.method="first")) %>%
mutate(pop = ipop, age = age_spec[j]) %>%
mutate(rel_rank_RMSE = RMSE_rank/n(),
rel_rank_all = Overall_rank/n()) %>%
arrange(Overall_rank)
tb <- bind_rows(tb,pop_rank)
#fn<-paste0("retro_",pname[ipop],"_age_",age_spec[j],"newmodels_",yrname,".csv")
#fn<-paste0("ranking_tables/retro_",pname[ipop],"_age_",age_spec[j],".csv")
#write_csv(pop_rank,file = fn)
} #end k of select years
} # end j with age
} # end ipop population ID
write_csv(tb,file = "../data/organize_retro.csv")
new <- tb %>%
select(pop, model, rel_rank_all) %>%
pivot_wider(names_from = pop, values_from = rel_rank_all)
library(ggplot2)
ggplot(tb,aes(x = pop, y = model, fill = rel_rank_all)) +
geom_tile(colour = "white", size = 0.2)
## This program is used to create Ranking tables##
## and output to retro_all.csv
## questions about this code contract Yi Xu, yi.xu2@dfo-mpo.gc.ca
rm(list=ls())
library(tidyverse)
library(tidyverse)
detach("package:tidyverse", unload = TRUE)
remove.packages("tidyverse", lib="~/R/R-4.1.3/library")
install.packages("tidyverse")
library(tidyverse)
install.packages("rlang")
install.packages("rlang")
## This program is used to create Ranking tables##
## and output to retro_all.csv
## questions about this code contract Yi Xu, yi.xu2@dfo-mpo.gc.ca
rm(list=ls())
library(tidyverse)
